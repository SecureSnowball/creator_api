import { HttpContextContract } from '@ioc:Adonis/Core/HttpContext'
import {{ table.names.pascalCase }} from 'App/Models/{{ table.names.pascalCase }}';
@if(table.operations.includes('store'))
  import Store{{
    table.names.pascalCase
  }}Validator from 'App/Validators/Store{{ table.names.pascalCase }}Validator';
@endif
@if(table.operations.includes('update'))
  import Update{{
    table.names.pascalCase
  }}Validator from 'App/Validators/Update{{ table.names.pascalCase }}Validator';
@endif
@if(Array.isArray(table.routeParents) && table.routeParents.length)
  @each(parent in table.routeParents)
    import {{ pascalCase(parent) }} from 'App/Models/{{ pascalCase(parent) }}';
  @endeach
@endif

export default class {{ table.names.pascalCasePlural }}Controller {
  @if(table.operations.includes('index'))
    public async index({ auth, request }: HttpContextContract) {
      const page = request.input('page', 1)
      const size = request.input('size', 10)
      @each(parent in table.routeParents)
        const {{ parent }}Id = request.param('{{ parent }}Id');
      @endeach

      @each(parent in table.routeParents)
        await {{ pascalCase(parent) }}.query().where({
          id: {{ parent }}Id
        }).firstOrFail()
      @endeach

      return {{ table.names.pascalCase }}.query()
      .where({
      @if(table.relations.find(relation => relation.type === 'belongsTo' && relation.withModel === '$auth'))
        {{
          input.camelCaseStrategy ?
            `${input.auth.table.names.camelCase}Id` :
            `${input.auth.table.names.snakeCase}_id`
        }}: auth.user!.id,
      @endif
      @if(Array.isArray(table.routeParents) && table.routeParents.length)
        @set('lastIndex', table.routeParents.length - 1)
        {{ table.routeParents[lastIndex] }}Id,
      @endif
      })
      .paginate(page, size)
    }
  @endif

  @if(table.operations.includes('store'))
    public async store({ auth, request }: HttpContextContract) {
      const input: { [key: string]: any } = await request.validate(Store{{
        table.names.pascalCase
      }}Validator)
      @if(table.relations.find(relation => relation.type === 'belongsTo' && relation.withModel === '$auth'))
        input.{{
          input.camelCaseStrategy ?
            `${input.auth.table.names.camelCase}Id` :
            `${input.auth.table.names.snakeCase}_id`
        }} = auth.user!.id
      @endif
      return {{ table.names.pascalCase }}.create(input)
    }
  @endif

  @if(table.operations.includes('show'))
    public async show({ auth, request }: HttpContextContract) {
      const id = request.param('id')
      const condition: { [key: string]: any } = { id }
      @if(table.relations.find(relation => relation.type === 'belongsTo' && relation.withModel === '$auth'))
        condition.{{
          input.camelCaseStrategy ?
            `${input.auth.table.names.camelCase}Id` :
            `${input.auth.table.names.snakeCase}_id`
        }} = auth.user!.id
      @endif
      return {{ table.names.pascalCase }}.query().where(condition).firstOrFail()
    }
  @endif

  @if(table.operations.includes('update'))
    public async update({ auth, request }: HttpContextContract) {
      const id = request.param('id')
      const condition: { [key: string]: any } = { id }
      @if(table.relations.find(relation => relation.type === 'belongsTo' && relation.withModel === '$auth'))
        condition.{{
          input.camelCaseStrategy ?
            `${input.auth.table.names.camelCase}Id` :
            `${input.auth.table.names.snakeCase}_id`
        }} = auth.user!.id
      @endif
      const input: { [key: string]: any } = await request.validate(Update{{ table.names.pascalCase }}Validator)
      const {{ table.names.camelCase }} = await {{ table.names.pascalCase }}.query().where(condition).firstOrFail()
      return {{ table.names.camelCase }}
        .merge(input)
        .save()
    }
  @endif

  @if(table.operations.includes('destroy'))
    public async destroy({ auth, request, response }: HttpContextContract) {
      const id = request.param('id')
      const condition: { [key: string]: any } = { id }
      @if(table.relations.find(relation => relation.type === 'belongsTo' && relation.withModel === '$auth'))
        condition.{{
          input.camelCaseStrategy ?
            `${input.auth.table.names.camelCase}Id` :
            `${input.auth.table.names.snakeCase}_id`
        }} = auth.user!.id
      @endif
      const {{ table.names.camelCase }} = await {{ table.names.pascalCase }}.query().where(condition).firstOrFail()
      await {{ table.names.camelCase }}.delete()
      return response.status(204)
    }
  @endif

  @if(table.operations.includes('destroyMany'))
    public async destroyMany({ request }: HttpContextContract) {
      return {{ table.names.pascalCase }}.query().whereIn('id', request.input('ids')).delete()
    }
  @endif
}
