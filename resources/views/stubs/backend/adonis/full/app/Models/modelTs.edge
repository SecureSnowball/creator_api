import { DateTime } from 'luxon'
@if(isAuth)
  import Hash from '@ioc:Adonis/Core/Hash'
@endif
import {
  column,
  @if(isAuth)
  beforeSave,
  @endif
  BaseModel,
  @if(table.relations.find(relation => relation.type === 'hasOne'))
  hasOne,
  HasOne,
  @endif
  @if(table.relations.find(relation => relation.type === 'hasMany'))
  hasMany,
  HasMany,
  @endif
  @if(table.relations.find(relation => relation.type === 'belongsTo'))
  belongsTo,
  BelongsTo,
  @endif
  @if(table.relations.find(relation => relation.type === 'manyToMany'))
  manyToMany,
  manyToMany,
  @endif
} from '@ioc:Adonis/Lucid/Orm'
@each(relation in table.relations)
import {{
  relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
}} from 'App/Models/{{
  relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
}}'
@endeach

export default class {{ table.names.pascalCase }} extends BaseModel {

  @column({ isPrimary: true })
  public id: number

  @each(column in table.columns)

    @if(column.type === 'date')
      @column.dateTime()
      public {{ column.names.camelCase }}{{ column.meta.required ? '?': '' }}: DateTime
    @else
      @if(column.meta.secret)
        @column({
          serializeAs: null
        })
      @elseif(column.type === 'boolean' && input.database === 'mysql')
        @column({ serialize: (value) => !!value })
      @else
        @column()
      @endif
      public {{ column.names.camelCase }}{{ column.meta.required ? '': '?' }}: {{
        ['decimal', 'integer'].includes(column.type) ? 'number' : column.type
      }}
    @endif
  @endeach

  @if(table.timestamps)
      @column.dateTime({ autoCreate: true })
      public createdAt: DateTime

      @column.dateTime({ autoCreate: true, autoUpdate: true })
      public updatedAt: DateTime
  @endif

  @each(relation in table.relations)
    @if(relation.type === 'hasOne')
      @hasOne(() => {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }})
      public {{
        relation.withModel === '$auth' ? input.auth.table.names.camelCase : relation.names.camelCase
      }}: HasOne<typeof {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }}>
    @elseif(relation.type === 'hasMany')
      @hasMany(() => {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }})
      public {{
        relation.withModel === '$auth' ? input.auth.table.names.camelCasePlural : relation.names.camelCasePlural
      }}: HasMany<typeof {{ relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase }}>
    @elseif(relation.type === 'belongsTo')
      @belongsTo(() => {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }})
      public {{
        relation.withModel === '$auth' ? input.auth.table.names.camelCase : relation.names.camelCase
      }}: BelongsTo<typeof {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }}>
    @elseif(relation.type === 'manyToMany')
      @manyToMany(() => {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }})
      public {{
        relation.withModel === '$auth' ? input.auth.table.names.camelCasePlural : relation.names.camelCasePlural
      }}: ManyToMany<typeof {{
        relation.withModel === '$auth' ? input.auth.table.names.pascalCase : relation.names.pascalCase
      }}>
    @endif
  @endeach

  @if(isAuth)

  @beforeSave()
  public static async hashPassword (user: User) {
    if (user.$dirty.password) {
      user.password = await Hash.make(user.password)
    }
  }
@endif
}
