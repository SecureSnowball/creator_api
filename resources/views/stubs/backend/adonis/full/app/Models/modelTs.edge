import { DateTime } from 'luxon'
@if(isAuth)
  import Hash from '@ioc:Adonis/Core/Hash'
@endif
import {
  column,
  @if(isAuth)
    beforeSave,
  @endif
  BaseModel,
  @if(table.relations.find(relation => relation.type === 'hasOne'))
    hasOne,
    HasOne,
  @endif
  @if(table.relations.find(relation => relation.type === 'hasMany'))
    hasMany,
    HasMany,
  @endif
  @if(table.relations.find(relation => relation.type === 'belongsTo'))
    belongsTo,
    BelongsTo,
  @endif
  @if(table.relations.find(relation => relation.type === 'manyToMany'))
    manyToMany,
    manyToMany,
  @endif
} from '@ioc:Adonis/Lucid/Orm'
@each(relation in table.relations)
import {{ relation.modelNames.pascalCase }} from 'App/Models/{{ relation.modelNames.pascalCase }}'
@endeach

export default class {{ table.names.pascalCase }} extends BaseModel {

  @column({ isPrimary: true })
  public id: number

  @each(column in table.columns)

    @if(column.type === 'date')
      @column.dateTime()
      public {{ column.names.camelCase }}{{ column.meta.required ? '?': '' }}: DateTime
    @else
      @if(column.meta.secret)
        @column({
          serializeAs: null
        })
      @elseif(column.type === 'boolean' && input.database === 'mysql')
        @column({ serialize: (value) => !!value })
      @else
        @column()
      @endif
      public {{ column.names.camelCase }}{{ column.meta.required ? '': '?' }}: {{
        ['decimal', 'integer'].includes(column.type) ? 'number' : column.type
      }}
    @endif
  @endeach

  @each(relation in table.relations)
    @if(relation.type === 'belongsTo')
    @column()
    public {{ relation.names.camelCase }}Id{{relation.required ? '?': '' }}: number
    @endif
  @endeach

  @if(table.timestamps)
      @column.dateTime({ autoCreate: true })
      public createdAt: DateTime

      @column.dateTime({ autoCreate: true, autoUpdate: true })
      public updatedAt: DateTime
  @endif

  @each(relation in table.relations)
    @if(relation.type === 'hasOne')
      @hasOne(() => {{ relation.modelNames.pascalCase }})
      public {{
        relation.names.camelCase
      }}{{relation.required ? '?': '' }}: HasOne<typeof {{ relation.modelNames.pascalCase }}>
    @elseif(relation.type === 'hasMany')
      @hasMany(() => {{ relation.modelNames.pascalCase }})
      public {{
        relation.names.camelCasePlural
      }}{{relation.required ? '?': '' }}: HasMany<typeof {{ relation.modelNames.pascalCase }}>
    @elseif(relation.type === 'belongsTo')
      @belongsTo(() => {{ relation.modelNames.pascalCase }})
      public {{
        relation.names.camelCase
      }}{{relation.required ? '?': '' }}: BelongsTo<typeof {{ relation.modelNames.pascalCase }}>
    @elseif(relation.type === 'manyToMany')
      @manyToMany(() => {{ relation.modelNames.pascalCase }})
      public {{
        relation.modelNames.camelCasePlural
      }}{{relation.required ? '?': '' }}: ManyToMany<typeof {{ relation.modelNames.pascalCase }}>
    @endif
  @endeach

  @if(isAuth)

  @beforeSave()
  public static async hashPassword (user: User) {
    if (user.$dirty.password) {
      user.password = await Hash.make(user.password)
    }
  }
@endif
}
